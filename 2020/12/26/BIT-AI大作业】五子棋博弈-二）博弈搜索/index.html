<!DOCTYPE html>
<html lang="en">

<head>

  <!-- Minima -->
  <!-- Hexo theme created by @adisaktijrs -->

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">

  
  <title>【BIT AI大作业】五子棋博弈 (二）博弈搜索</title>
  
  <link rel="canonical" href="http://youwebsit.com/2020/12/26/BIT-AI%E5%A4%A7%E4%BD%9C%E4%B8%9A%E3%80%91%E4%BA%94%E5%AD%90%E6%A3%8B%E5%8D%9A%E5%BC%88-%E4%BA%8C%EF%BC%89%E5%8D%9A%E5%BC%88%E6%90%9C%E7%B4%A2/">
  
  <meta name="description" content="实验要求采用人工智能方法解决五子棋博弈问题，要求如下：  能够用拍照方式识别五子棋下棋过程中当前落子的位置，识别程序中应使用到监督学习算法。 采用一种博弈搜索算法，实现五子棋博弈程序，其中对棋局状态的判断采用人为设定函数方式。 将上述博弈搜索算法中判断棋局状态的函数改为一种人工神经网络模型，并采用进">
  
  
  <meta name="author" content="John Doe">
  
  <meta property="og:image" content="http://youwebsit.comundefined">
  
  <meta property="og:site_name" content="Hexo" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="【BIT AI大作业】五子棋博弈 (二）博弈搜索" />
  
  <meta property="og:description" content="实验要求采用人工智能方法解决五子棋博弈问题，要求如下：  能够用拍照方式识别五子棋下棋过程中当前落子的位置，识别程序中应使用到监督学习算法。 采用一种博弈搜索算法，实现五子棋博弈程序，其中对棋局状态的判断采用人为设定函数方式。 将上述博弈搜索算法中判断棋局状态的函数改为一种人工神经网络模型，并采用进">
  
  <meta property="og:url" content="http://youwebsit.com/2020/12/26/BIT-AI%E5%A4%A7%E4%BD%9C%E4%B8%9A%E3%80%91%E4%BA%94%E5%AD%90%E6%A3%8B%E5%8D%9A%E5%BC%88-%E4%BA%8C%EF%BC%89%E5%8D%9A%E5%BC%88%E6%90%9C%E7%B4%A2/" />

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="【BIT AI大作业】五子棋博弈 (二）博弈搜索">
  
  <meta name="twitter:description" content="实验要求采用人工智能方法解决五子棋博弈问题，要求如下：  能够用拍照方式识别五子棋下棋过程中当前落子的位置，识别程序中应使用到监督学习算法。 采用一种博弈搜索算法，实现五子棋博弈程序，其中对棋局状态的判断采用人为设定函数方式。 将上述博弈搜索算法中判断棋局状态的函数改为一种人工神经网络模型，并采用进">
  
  
  <meta name="twitter:image" content="http://youwebsit.comundefined">
  
  <meta name="twitter:url" content="http://youwebsit.com/2020/12/26/BIT-AI%E5%A4%A7%E4%BD%9C%E4%B8%9A%E3%80%91%E4%BA%94%E5%AD%90%E6%A3%8B%E5%8D%9A%E5%BC%88-%E4%BA%8C%EF%BC%89%E5%8D%9A%E5%BC%88%E6%90%9C%E7%B4%A2/" />

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Preload fonts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="preload" href="../fonts/dm-serif-display-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="../fonts/inter-v2-latin-regular.woff2" as="font" type="font/woff2" crossorigin>

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  
<link rel="stylesheet" href="/css/normalize.css">

  
<link rel="stylesheet" href="/css/skeleton.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
<link rel="stylesheet" href="/css/prism-dark.css">

  
<link rel="stylesheet" href="/css/prism-line-numbers.css">

  <!-- User css -->
  
  
<link rel="stylesheet" href="/css/user.css">

  

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">

  <!-- Custom Theme Color Style
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <style>
  a:not(.icon) {
    text-decoration-color: #0FA0CE;
    background-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0) 50%,
      #0FA0CE 50%
    );
  }
  blockquote {
    border-left: 8px solid #0FA0CE;
  }
  .nanobar .bar {
    background: #0FA0CE;
  }
  .button.button-primary:hover,
  button.button-primary:hover,
  input[type="submit"].button-primary:hover,
  input[type="reset"].button-primary:hover,
  input[type="button"].button-primary:hover,
  .button.button-primary:focus,
  button.button-primary:focus,
  input[type="submit"].button-primary:focus,
  input[type="reset"].button-primary:focus,
  input[type="button"].button-primary:focus {
    background-color: #0FA0CE;
    border-color: #0FA0CE;
  }
  input[type="email"]:focus,
  input[type="number"]:focus,
  input[type="search"]:focus,
  input[type="text"]:focus,
  input[type="tel"]:focus,
  input[type="url"]:focus,
  input[type="password"]:focus,
  textarea:focus,
  select:focus {
    border: 1px solid #0FA0CE;
  }
</style>

  <!-- Google Analytics (With Privacy Settings On)
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  

<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div class="container">
    <div class="row">
      <div>

        <div class="row">
  <div class="two columns" style="max-width: 50px">
    <h1 class="mt-2 mode">
      <div onclick=setDarkMode(true) id="darkBtn">🌑</div>
      <div onclick=setDarkMode(false) id="lightBtn" class=hidden>☀️</div>
      <script >
        if (localStorage.getItem('preferredTheme') == 'dark') {
          setDarkMode(true)
        }
        function setDarkMode(isDark) {
          var darkBtn = document.getElementById('darkBtn')
          var lightBtn = document.getElementById('lightBtn')
          if (isDark) {
            lightBtn.style.display = "block"
            darkBtn.style.display = "none"
            localStorage.setItem('preferredTheme', 'dark');
          } else {
            lightBtn.style.display = "none"
            darkBtn.style.display = "block"
            localStorage.removeItem('preferredTheme');
          }
          document.body.classList.toggle("darkmode");
        }
      </script>
    </h1>
  </div>

  <div class="six columns ml-1">
    <h1 class="mt-2">
      Hi Folks.
    </h1>
  </div>

  <div class="twelve columns">
    <div class="row">
      <div class="nine columns left">
        <a href="/">Home</a>
        
          
          <a href="/Works" class="ml">Works</a>
          
        
          
          <a href="/About" class="ml">About</a>
          
        
        
          
            <a href="mailto:test@test.test" target="_blank" class="ml">Email</a>
          
        
      </div>
    </div>
    <hr style="margin-bottom: 2.6rem">
  </div>
</div>

        <div class="trans">
            <h2>【BIT AI大作业】五子棋博弈 (二）博弈搜索</h2>

  <h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a><a href="">实验要求</a></h2><p>采用人工智能方法解决五子棋博弈问题，要求如下：</p>
<ul>
<li>能够用拍照方式识别五子棋下棋过程中当前落子的位置，识别程序中应使用到监督学习算法。</li>
<li><strong>采用一种博弈搜索算法，实现五子棋博弈程序，其中对棋局状态的判断采用人为设定函数方式。</strong></li>
<li>将上述博弈搜索算法中判断棋局状态的函数改为一种人工神经网络模型，并采用进化计算方法对该人工神经网络模型来进行学习，使得五子棋博弈程序的下棋水平不断提高。 </li>
<li>采用强化学习算法对上述人工神经网络模型进行学习，使得五子棋博弈程序的下棋水平不断提高。 </li>
</ul>
<h4 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a><a href="">实验思路</a></h4><p>设置一个表示棋局逻辑的类Gobang中，再设置一个继承自Gobang的类GobangPlay用于绘制棋盘前端并实现轮流下棋的循环过程。</p>
<p>接着写一个由博弈搜索算法构成的类MGT_AI，将其接入到Gobang中的self.myAI中。其基本原理为根据当前棋盘，用极大极小搜索法搜索每一个可落子的位置的分数，返回最高分的位置，作为AI的下一步。其中对于叶节点的估分，采用了人为设定函数的方式，将棋形分为连五、活四、冲四、活三、眠三、活二、眠二七种棋形，并分别为其设定合适的分数，最后用己方棋形分数之和减去敌方棋形分数和，即得到当前棋局的分数。具体棋形如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Narumi-Maria/CDN/images/pasted-15.png" alt="upload successful"></p>
<p>为提高搜索速度，我采用了多种策略。包括alpha-beta剪枝、如果出现连五、活四的位置，则只走这些位置，从而减少每一层的搜索范围、只搜索和当前棋盘上半径为1的范围内的空位、大概估计可行走范围的分数并排序，只搜索估分最高的前几个区域等。</p>
<p>具体的实现流程如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Narumi-Maria/CDN/images/pasted-16.png" alt="upload successful"></p>
<h4 id="构建表示棋局逻辑的类Gobang"><a href="#构建表示棋局逻辑的类Gobang" class="headerlink" title="构建表示棋局逻辑的类Gobang"></a><a href="">构建表示棋局逻辑的类Gobang</a></h4><p><a href="">1）初始化</a></p>
<p>在<code>__init__</code>中设置棋盘大小（默认为15*15），并维护以下两个数据结构：</p>
<ul>
<li><p>self.map：一个15*15的列表，每个数字表示棋盘中的一位。这里设置黑棋为1，白棋为-1，空位为0。这样的设计有很多好处，第一，在递归搜索中可以通过加一个负号直接改变顺序，第二，在强化学习中可以有更好的收敛性，第三，在第一问的拍照识别落子位置中可以有更好的训练效果。</p>
</li>
<li><p>self.moveStack：一个列表，储存着每局从开始到现在所有的落子颜色和坐标。其内元素的结构为（颜色1/-1，x，y）。</p>
</li>
</ul>
<p>将由博弈搜索算法构成的类MGT_AI接入到self.myAI中。</p>
<p><a href="">2）接受黑棋落子的函数player_move(self, x, y)</a></p>
<p>该函数接受一个坐标对x，y作为输入，根据self.map判断该坐标是否已有棋子存在，如果有则输出错误提示信息并返回False。如果该位置可落子，则接受该落子，将self.map[x][y]置1，并将（1，x，y）加入到self.moveStack中，返回True。</p>
<p><a href="">3）接受白棋落子的函数ai_move(self)</a></p>
<p>该函数将当前棋盘self.map传入到AI中，并根据AI的最佳位置x，y接受该落子。即将self.map[x][y]置-1，并将（-1，x，y）加入到self.moveStack中。</p>
<p><a href="">4）判断是否有赢家产生的函数check_result(self)</a></p>
<p>每一个人下完一步后，都会调用该函数判断是否有赢家产生。其具体方法是得到self.moveStack的最后一个落子信息，并通过self.map检查最后一次落子所在的行、列、左斜线、右斜线是否有连成5子的情况：</p>
<ul>
<li>若有，则返回棋盘最后一次落子的颜色标记，表示该颜色的棋手赢得比赛（即，返回1为黑棋赢，返回-1为白棋赢）。</li>
<li>若四条线上都没有五子产生，判断self.moveStack中的棋子数量是否已经等于棋盘所有位置，若等于，则返回2，表示棋盘下满仍未出现赢家，为和棋。</li>
<li>若上述情况均未发生，返回0，表示该轮没有赢家产生，游戏继续。</li>
</ul>
<h4 id="2-构建继承自Gobang的类GobangPlay，用于绘制棋盘前端并实现轮流下棋的循环过程"><a href="#2-构建继承自Gobang的类GobangPlay，用于绘制棋盘前端并实现轮流下棋的循环过程" class="headerlink" title="2.构建继承自Gobang的类GobangPlay，用于绘制棋盘前端并实现轮流下棋的循环过程"></a><a href="">2.构建继承自Gobang的类GobangPlay，用于绘制棋盘前端并实现轮流下棋的循环过程</a></h4><p><a href="">1）初始化</a></p>
<p>在<code>__init__</code>中设置绘制前端的一些基本信息，具体如下：</p>
<ul>
<li>self.SIZE：棋盘大小</li>
<li>self.UNIT：两条线之间的间距</li>
<li>self.TITLE：窗口标题</li>
<li>self.BORDER_WIDTH：棋盘预留宽度</li>
<li>self.MAP_RANGE：棋盘范围</li>
<li>self.WINDOW_RANGE：窗口的宽（我做的窗口是一个棋盘在中央的正方形）</li>
<li>其他用于绘制按钮及主界面的参数</li>
</ul>
<p>接着，初始化pygame，根据self.WINDOW_RANGE大小生成窗口self.screen，并写入窗口标题。</p>
<p>调用类中自己实现的函数Draw_Map，该函数中使用pygame的函数实现大部分功能。包括：</p>
<ul>
<li>加载bg.jpg（一张木质背景图）作为棋盘的背景图。</li>
<li>根据预设好的参数大小绘制棋盘中的网格。</li>
<li>根据self.moveStack中的棋子信息绘制棋子（初始时为空，不绘制）</li>
</ul>
<p><a href="">2）绘制当前黑棋（玩家）落子的函数Player_Move(self, pos)</a></p>
<p>该函数接受一个坐标对pos作为输入，但是这里的pos是鼠标点击的位置。我使用round函数将其吸附到最近的落棋点，然后判断该位置是否合法：</p>
<ul>
<li>如果超出棋盘边界，或调用父类中的函数player_move得到的返回值为False，则拒绝该落子，返回False。</li>
<li>若落子位置合法，调用pygame中的函数，将当前的棋子画入前端。</li>
</ul>
<p><a href="">3）绘制白棋（AI）落子的函数AI_Move(self)</a></p>
<p>调用self.ai_move()，使ai下的白棋计入棋局逻辑。接着导出self.moveStack中的最后一枚棋子（这枚棋子就是ai刚刚下的棋），调用pygame中的函数，将棋子画入前端。</p>
<p><a href="">4）实现玩家与AI轮流下棋的循环过程的函数Start_MGT_or_RL_or_GA(self, ai=’MGT’)：</a></p>
<p>调用pygame.event.get()获取前端用户操作：</p>
<ul>
<li>若event.type == QUIT，表示用户关闭了窗口，游戏结束，程序结束。</li>
<li>若event.type == MOUSEBUTTONUP，表示当前有鼠标点击，发生了落子事件，获取鼠标落子的位置并传入self.Player_Move中，实现玩家落子。玩家落子结束后调用父类的函数check_result，判断玩家走这一步后是否能赢得比赛。若未赢，调用函数AI_Move(self)走一步，AI落子结束后调用父类的函数check_result，判断AI走这一步后是否能赢得比赛。若未赢，继续游戏循环。若在玩家或AI落子后有赢家产生，调用Win函数显示赢家。</li>
</ul>
<p><a href="">5）Start_MGT_or_RL_or_GA(self, ai=’MGT’)</a></p>
<p>这是我写的用于展示强化学习互博的一个函数。具体实现过程与Start_MGT_or_RL_or_<br>GA类似，只是这里我把人机交互改成了机器交互。</p>
<p><a href="">6）主循环函数Start(self)</a></p>
<p>首先调用pygame.event.get()获取前端用户操作，然后根据鼠标点击的范围确定用户要与哪一个AI进行下棋。一共有以下四种选择，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Narumi-Maria/CDN/images/pasted-17.png" alt="upload successful"></p>
<p>点击第一个按钮，会展示未经训练的强化学习互博10轮和经过三万多轮训练的强化学习互博的过程，以此对比来凸显强化学习的成果。点击第2、3、4个按钮，会有对应的AI与玩家下棋。下棋结束后停留1秒显示结果，然后会回到主界面。</p>
<h4 id="构建由博弈搜索算法构成的类MGT-AI"><a href="#构建由博弈搜索算法构成的类MGT-AI" class="headerlink" title="构建由博弈搜索算法构成的类MGT_AI"></a><a href="">构建由博弈搜索算法构成的类MGT_AI</a></h4><p><a href="">1）初始化</a></p>
<p>在__init__中维护以下数据结构：</p>
<ul>
<li>self.record：记录每个棋子的横、纵、左斜、右斜是否被检查过</li>
<li>self.count：记录黑白棋棋形个数之和（精确计算中使用）</li>
<li>self.ecount：记录黑白棋棋形个数之和（大概估计中使用）<br><code>self.count和self.ecount都是维度为[8][3]的列表。第一个维度指棋形（共有连五、活四、冲四、活三、眠三、活二、眠二七种，加一维为空），第二个维度指棋手（[0]为空，[1]表示黑棋，[-1]=[2]表示白棋，借用了python可以用负数从后数维度的这样一个便利，使count[i][turn]可以直接表示当前棋手的第i个棋形的数量）。</code></li>
<li>self.best_move：保存得分最高的位置坐标</li>
<li>self.max_depth：搜索的最大深度</li>
</ul>
<p><a href="">2）AI的入口函数Get_best_chess(self, map, turn)</a></p>
<p>每一次调用MGT_AI这个类搜寻落子位置时，先将self.best_move置为None，然后将棋盘列表和当前落子颜色（用turn表示，1表示黑棋，-1表示白棋）传入搜索函数self.DFS，默认搜索深度为4层，得到搜索到的最佳落子位置的分数。结束搜索后，self.best_move中也保存了最佳落子位置，打印搜索时间、最佳落子位置的分数和最佳落子位置的坐标，并将最佳落子位置的坐标（x，y）返回。</p>
<p><a href="">3）极大极小深度优先搜索结合alpha-beta剪枝的函数DFS(self, map, turn, depth =AI_SEARCH_DEEP, alpha=SCORE_MIN, beta=SCORE_MAX)</a></p>
<p>首先简要介绍以下这里的搜索原理，由于五子棋博弈过程是经典的零和博弈过程，故此每一方都希望自己能走出得分最高的一步。这里假设对手的信息是完备的，即对手也会按照最佳的策略去走，则构成了一个极大极小搜索的体系。在极大极小搜索中，根节点为max层，往下是min层和max层的交替。max层节点的值选择子节点中的最大值，min层节点的值选择子节点中的最小值，搜索过程为深度优先搜索，将叶节点的分数逐层向上回溯，最终即可得到根节点的值，而根节点的值即为所求。</p>
<p>由于当前的根节点轮到AI走，故AI在max层，玩家在min层。在每一层搜索过程中，会找出每一个可下的位置作为扩展节点，向下搜索。在搜索过程中，我传递的是棋局，即根节点表示当前AI面对的棋局，博弈树上每一个节点就是从树根节点开始，每个子节点轮流下一步棋，到该节点形成的新的棋局。综上，棋局就是所有已下棋位置的顺序列表。</p>
<p>当搜索到叶节点（即达到最大搜索深度或搜到连5结点、无路可走的结点）时，则调用人为设定的棋盘估值函数，对当前棋局进行估值，作为叶节点的分数返回。经过逐层向上更新，根节点得到最佳位置的最大的分数，而将这个最大分数反馈给根节点的子节点，即代表了AI下一步落子的位置。</p>
<p>在搜索过程中，当博弈树的层数变大时，需要搜索的节点数目会指数级增长。于是我使用alpha-beta剪枝将搜索树中不需要搜索的分支裁剪掉，以提高运算速度。</p>
<p>这里我简单介绍一下alpha-beta剪枝的原理，首先，alpha记录max层节点的下界，beta记录min层节点的上界。所谓的alpha剪枝，就是在max层的搜索过程中，如果其子节点（子节点在min层）的beta值小于等于alpha，那么就停止搜索这一子节点，因为min层节点继续搜索下去的值只会越来越小。而对应的beta剪枝，就是在min层搜索的过程中，如果其子节点的alpha值大于等于beta，就将这一子节点剪去。初始时设根节点的alpha值为负无穷，beta值为正无穷。深搜时将父节点的alpha、beta值传递给子节点，max层节点在回溯过程中只更新alpha值，min层节点在回溯过程中只更新beta值。</p>
<p>这里我采用了一个小技巧，在递归搜索的过程中，互换alpha、beta的值并取负，将返回的分数也取负，可以保证score永远只更新alpha的值，而剪枝条件永远为alpha&gt;=beta，简便编程。</p>
<p>接下来对函数实现的具体流程进行介绍：</p>
<ul>
<li>调用score = self.Evaluate(map, turn)，传入棋盘列表和当前落子颜色，得到当前棋局的分数。</li>
<li>如果达到最大搜索深度，或者能连5的位置，则不再搜索。返回分数。</li>
<li>调用self.Generate_move(map, turn)，传入棋盘列表和当前落子颜色，得到当前棋局每一个可走的位置构成的列表。如果该列表长度为0，说明已经无路可走了，则不再搜索，返回当前分数。</li>
<li>如果不是b、c所谈论的搜索到叶节点的情况，那么刚刚得到的score无效。遍历可走的位置构成的列表，尝试每一个可走的位置，即，把棋盘列表的对应位置设置为当前落子颜色。然后对新的棋盘，将棋手顺序turn取负，调用DFS函数进行递归搜索得到当前节点子节点的分数。这里我使用了一个小技巧，即互换互换alpha、beta的值并取负，将返回的分数也取负，可以保证score永远只更新alpha的值，而剪枝条件永远为alpha&gt;=beta，简便编程。</li>
<li>得到递归搜索的结果后，恢复棋局，即，把棋盘列表刚刚尝试走过的位置恢复为空。</li>
<li>判断是否需要用子节点的score值更新当前节点的score值，并判断是否需要进行alpha-beta剪枝。如果当前搜索深度等于最大搜索深度，那么就将当前尝试的位置保存在self.best_move中。</li>
<li>结束搜索后，返回根节点的分数，即为最佳位置的最大分数。</li>
</ul>
<p><a href="">4）得到叶节点分数的棋局估值函数Evaluate(self, map, turn)、遍历该点的四个方向的函数Evaluate_point(self, map, x, y, turn, count=None)、评价该点当前方向上的分数，并存入count数组之中的函数Analysis_line(self, map, x, y, direction_index, direction, turn, count)、对于具体的一条线，以选取点为中心，取该方向前四点和后四点组成长为9的列表的函数Get_line(self, map, x, y, direction, turn)</a></p>
<ul>
<li>每次进入Evaluate函数中评估棋局前，先清空self.record和self.count。</li>
<li>遍历棋盘上的每一个点，调用Evaluate_point函数，由Evaluate_point函数遍历该点的横、纵、左斜、右斜四个方向，在每一个方向上再调用Analysis_line函数，由Get_line函数得到以当前棋子为中心的该方向上的9个棋子列表，将超出棋盘范围的部分都设置为对手的棋子，搜索棋形个数并存入self.count中。为避免重复计数，会将该点被计数棋形方向上的其它棋子的该方向在self.record中进行标记。</li>
<li>在Analysis_line中，用left_idx和right_idx表示turn方棋手的棋已经连成的范围，left_idx和right_idx表示turn方棋手的棋加上空位可能连成的范围。如果可连的范围小于5，那么以当前棋子为中心的该方向线上的所有可连位置的棋子都是没有棋形，直接返回。否则，对连五、活四、冲四、活三、眠三、活二、眠二七种棋形分别判断存在并计数，存入count中。并在self.record标记重复。</li>
<li>在Evaluate_point函数和Analysis_line函数都遍历执行完毕后，根据每种棋形设定的打分规则，按count中的棋形数打分，count[i][turn]是己方第i种棋型数，count[-turn]是对方第i种棋形数，返回的分数为己方分减去对方分。</li>
</ul>
<p><a href="">5）寻找当前棋盘上棋子周围的位置中可下棋位的函数Generate_move(self, map, turn, limit=AI_LIMITED_MOVE_NUM)、查看在该位置在指定半径内（这里设为1）有没有棋子的函数Has_neighbor(self, map, x, y, radius=AI_SEARCH_RADIUS)、大概估计该点的分数的函数Estimate_point(self, map, x, y, turn)、计算ecount的分数的函数Estimate_score(self, ecount)</a></p>
<p>首先先说明一下这些函数设立的意图：在alpha-beta剪枝的基础上进一步缩小搜索范围，使博弈树每层搜索的节点更少，减少搜索时间。下面阐释具体的实现步骤：</p>
<ul>
<li>首先进入到Generate_move函数中，设立四个列表moves、fives、 fours,、sfours，第一个列表moves表示要返回的可以下棋的位置，剩下三个列表设立的意图如下：如果有可以连五、活四或冲四的位置，则只搜索这些位置。</li>
<li>遍历棋盘上的每一个点，如果是空位，且调用Has_neighbor后发现该空位半径为一的范围内有棋子（避免搜索一些离当前棋局过远的位置，减少搜索时间），则调用Estimate_point函数，得到己方、对方的大概分数。由于不光要走自己的，也要防对手的，所以己方和对方的分数取最大值，根据最大值分数判断是否有连五、活四或冲四的位置。如果有，则在将该点（score，x，y）加入到moves列表的基础上，再加入到fives、 fours、sfours对应的列表中。否则，只加入到moves列表中。</li>
<li>在Estimate_point函数中，首先先对self.ecount清零。接着采用与4）完全相同的方式调用Evaluate_point和Analysis_line搜索以该点位中心的四个方向上的棋形，只是此时是将这些棋形计入到self.ecount中。由此我们也不难看出self.count和self.ecount两个数据结构的区别：self.count储存的是一个棋盘的棋形，而self.ecount储存的是一个棋子的棋形。然后调用Estimate_score，对self.ecount中的棋形计算其分数。注意Estimate_score中的评分体系是与4）中不同的。</li>
<li>遍历完棋盘后，如果fives、 fours、sfours这几个列表不为空，则只返回这几个列表（按优先级返回对应的列表）。否则，将moves中的棋子按score排序，只取前20返回，以达到进一步减少搜索范围的效果。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a><a href="">代码</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">棋局逻辑 GobangLogic.py</span></span><br><span class="line"><span class="string">map表示棋盘 横纵分别有15条线 0为空 1为黑 -1为白 黑棋先走 玩家为黑棋 AI为白棋</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">from task2_Minimax_game_tree import *</span><br><span class="line">from task4_DeepQ_learning import *</span><br><span class="line">from task3_GAnet import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GoBang:</span><br><span class="line">    def __init__(self, mapsize=15):</span><br><span class="line">        self.mapSize = mapsize</span><br><span class="line">        self.map = [[0 <span class="keyword">for</span> y <span class="keyword">in</span> range(0, mapsize)] <span class="keyword">for</span> x <span class="keyword">in</span> range(0, mapsize)]</span><br><span class="line">        self.moveStack = []</span><br><span class="line">        self.MGT_AI = MGT_AI(mapsize)</span><br><span class="line">        self.RL_AI = DQN()</span><br><span class="line">        self.GA_AI = GA()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 玩家走一步</span></span><br><span class="line">    def player_move(self, x, y, turn=1):</span><br><span class="line">        <span class="keyword">if</span> 0 &lt;= x &lt;= 14 and 0 &lt;= y &lt;= 14:</span><br><span class="line">            <span class="keyword">if</span> self.map[x][y] == 0:</span><br><span class="line">                self.map[x][y] = turn</span><br><span class="line">                self.moveStack.append((turn, x, y))</span><br><span class="line">                <span class="built_in">return</span> True</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;player move pos error!\n&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;player move pos error!\n&quot;</span>)</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line"></span><br><span class="line">    <span class="comment"># AI走一步</span></span><br><span class="line">    def ai_move(self, ai=<span class="string">&#x27;MGT&#x27;</span>, turn=-1):</span><br><span class="line">        <span class="keyword">if</span> ai == <span class="string">&#x27;MGT&#x27;</span>:</span><br><span class="line">            board = [[0 <span class="keyword">for</span> y <span class="keyword">in</span> range(0, self.mapSize)] <span class="keyword">for</span> x <span class="keyword">in</span> range(0, self.mapSize)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.mapSize):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(self.mapSize):</span><br><span class="line">                    board[i][j] = self.map[i][j]</span><br><span class="line">            x, y = self.MGT_AI.Get_best_chess(board, -1)</span><br><span class="line">            self.map[x][y] = -1</span><br><span class="line">            self.moveStack.append((-1, x, y))</span><br><span class="line">        <span class="keyword">if</span> ai == <span class="string">&#x27;DQN&#x27;</span>:</span><br><span class="line">            x, y = self.RL_AI.find_best_pos(self.map, turn)</span><br><span class="line">            self.map[x][y] = turn</span><br><span class="line">            self.moveStack.append((turn, x, y))</span><br><span class="line">        <span class="keyword">if</span> ai == <span class="string">&#x27;GA&#x27;</span>:</span><br><span class="line">            x, y = self.GA_AI.find_best_chess(self.map, turn)</span><br><span class="line">            self.map[x][y] = turn</span><br><span class="line">            self.moveStack.append((turn, x, y))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断最新一步是否会产生赢家 return 1黑棋赢 2平局 -1白棋赢 0未结束</span></span><br><span class="line">    def check_result(self):</span><br><span class="line">        lastStep = self.moveStack[-1]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 竖向检查</span></span><br><span class="line">        sum = 0</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(self.mapSize):</span><br><span class="line">            <span class="keyword">if</span> y &gt; 0 and self.map[lastStep[1]][y] != self.map[lastStep[1]][y - 1]:</span><br><span class="line">                sum = 0</span><br><span class="line">            sum += self.map[lastStep[1]][y]</span><br><span class="line">            <span class="keyword">if</span> abs(sum) &gt;= 5:</span><br><span class="line">                <span class="built_in">return</span> lastStep[0]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 横向检查</span></span><br><span class="line">        sum = 0</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(self.mapSize):</span><br><span class="line">            <span class="keyword">if</span> x &gt; 0 and self.map[x][lastStep[2]] != self.map[x - 1][lastStep[2]]:</span><br><span class="line">                sum = 0</span><br><span class="line">            sum += self.map[x][lastStep[2]]</span><br><span class="line">            <span class="keyword">if</span> abs(sum) &gt;= 5:</span><br><span class="line">                <span class="built_in">return</span> lastStep[0]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 右斜检查 计算处左上角顶点坐标，xy递增达到右下角顶点</span></span><br><span class="line">        sum = 0</span><br><span class="line">        minDist = min(lastStep[1], lastStep[2])</span><br><span class="line">        topPoint = [lastStep[1] - minDist, lastStep[2] - minDist]</span><br><span class="line">        <span class="keyword">for</span> incr <span class="keyword">in</span> range(self.mapSize):</span><br><span class="line">            <span class="keyword">if</span> topPoint[0] + incr &gt; self.mapSize - 1 or topPoint[1] + incr &gt; self.mapSize - 1:  <span class="comment"># 不得超出棋盘边界</span></span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">            <span class="keyword">if</span> incr &gt; 0 and self.map[topPoint[0] + incr][topPoint[1] + incr] != self.map[topPoint[0] + incr - 1][</span><br><span class="line">                topPoint[1] + incr - 1]:</span><br><span class="line">                sum = 0</span><br><span class="line">            sum += self.map[topPoint[0] + incr][topPoint[1] + incr]</span><br><span class="line">            <span class="keyword">if</span> abs(sum) &gt;= 5:</span><br><span class="line">                <span class="built_in">return</span> lastStep[0]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 左斜检查 计算右上角顶点坐标，x递减y递增到达左下顶点</span></span><br><span class="line">        sum = 0</span><br><span class="line">        minDist = min(self.mapSize - 1 - lastStep[1], lastStep[2])</span><br><span class="line">        topPoint = [lastStep[1] + minDist, lastStep[2] - minDist]</span><br><span class="line">        <span class="keyword">for</span> incr <span class="keyword">in</span> range(self.mapSize):</span><br><span class="line">            <span class="keyword">if</span> topPoint[0] - incr &lt; 0 or topPoint[1] + incr &gt; self.mapSize - 1:  <span class="comment"># 不得超出棋盘边界</span></span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">            <span class="keyword">if</span> incr &gt; 0 and self.map[topPoint[0] - incr][topPoint[1] + incr] != self.map[topPoint[0] - incr + 1][</span><br><span class="line">                topPoint[1] + incr - 1]:</span><br><span class="line">                sum = 0</span><br><span class="line">            sum += self.map[topPoint[0] - incr][topPoint[1] + incr]</span><br><span class="line">            <span class="keyword">if</span> abs(sum) &gt;= 5:</span><br><span class="line">                <span class="built_in">return</span> lastStep[0]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 平局</span></span><br><span class="line">        <span class="keyword">if</span> len(self.moveStack) &gt;= self.mapSize ** 2:</span><br><span class="line">            <span class="built_in">return</span> 2</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> 0</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">GobangPlay.py</span></span><br><span class="line"><span class="string">游戏主体，继承于棋局逻辑，用于实现游戏循环和绘制前端</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">from GobangLogic import GoBang</span><br><span class="line">import pygame</span><br><span class="line">import sys</span><br><span class="line">from pygame.locals import *</span><br><span class="line">import time</span><br><span class="line">import torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 颜色常量</span></span><br><span class="line">BLACK = (0, 0, 0)</span><br><span class="line">WHITE = (255, 255, 255)</span><br><span class="line">BLUE = (0, 0, 255)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GobangPlay(GoBang):</span><br><span class="line">    def __init__(self, mapsize=15, mapunit=30):</span><br><span class="line">        super(GobangPlay, self).__init__(mapsize=mapsize)</span><br><span class="line">        self.SIZE = mapsize</span><br><span class="line">        self.UNIT = mapunit  <span class="comment"># 两条线之间的间距</span></span><br><span class="line">        self.TITLE = <span class="string">&quot;五子棋游戏&quot;</span></span><br><span class="line">        self.BORDER_WIDTH = 50  <span class="comment"># 棋盘预留宽度</span></span><br><span class="line"></span><br><span class="line">        self.WINDOW_RANGE = self.BORDER_WIDTH * 2 + (self.SIZE - 1) * self.UNIT  <span class="comment"># 窗口大小</span></span><br><span class="line">        <span class="comment"># 跳到强化学习互博的按钮</span></span><br><span class="line">        self.BTN_RLvsRL_X = [170, 350]</span><br><span class="line">        self.BTN_RLvsRL_Y = [110, 170]</span><br><span class="line">        <span class="comment"># 跳到第二问的按钮</span></span><br><span class="line">        self.BTN_MGT_AI_X = [170, 350]</span><br><span class="line">        self.BTN_MGT_AI_Y = [200, 260]</span><br><span class="line">        <span class="comment"># 跳到第三问的按钮</span></span><br><span class="line">        self.BTN_GA_AI_X = [170, 350]</span><br><span class="line">        self.BTN_GA_AI_Y = [290, 350]</span><br><span class="line">        <span class="comment"># 跳到第四问的按钮</span></span><br><span class="line">        self.BTN_RL_AI_X = [170, 350]</span><br><span class="line">        self.BTN_RL_AI_Y = [380, 440]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 游戏初始化</span></span><br><span class="line">        pygame.init()</span><br><span class="line">        self.panel_font = pygame.font.SysFont(<span class="string">&#x27;SimHei&#x27;</span>, 20)  <span class="comment"># 字体</span></span><br><span class="line">        self.screen = pygame.display.set_mode((self.WINDOW_RANGE, self.WINDOW_RANGE))  <span class="comment"># 主窗口</span></span><br><span class="line">        pygame.display.set_caption(self.TITLE)  <span class="comment"># 窗口标题</span></span><br><span class="line">        self.screen.blit(pygame.transform.scale(pygame.image.load(r<span class="string">&quot;pic/background.jpg&quot;</span>), (520, 520)), (0, 0))  <span class="comment"># 主界面背景图</span></span><br><span class="line">        <span class="comment"># 绘制按钮</span></span><br><span class="line">        pygame.draw.rect(self.screen, BLACK, [170, 110, 180, 60])</span><br><span class="line">        self.surface_btn = self.panel_font.render(f<span class="string">&#x27;强化学习自训练&#x27;</span>, False, WHITE)</span><br><span class="line">        self.screen.blit(self.surface_btn, [190, 130])</span><br><span class="line">        pygame.draw.rect(self.screen, BLACK, [170, 200, 180, 60])</span><br><span class="line">        self.surface_btn = self.panel_font.render(f<span class="string">&#x27;与博弈树下棋&#x27;</span>, False, WHITE)</span><br><span class="line">        self.screen.blit(self.surface_btn, [190, 220])</span><br><span class="line">        pygame.draw.rect(self.screen, BLACK, [170, 290, 180, 60])</span><br><span class="line">        self.surface_btn = self.panel_font.render(f<span class="string">&#x27;与进化网络下棋&#x27;</span>, False, WHITE)</span><br><span class="line">        self.screen.blit(self.surface_btn, [190, 310])</span><br><span class="line">        pygame.draw.rect(self.screen, BLACK, [170, 380, 180, 60])</span><br><span class="line">        self.surface_btn = self.panel_font.render(f<span class="string">&#x27;与强化学习下棋&#x27;</span>, False, WHITE)</span><br><span class="line">        self.screen.blit(self.surface_btn, [190, 400])</span><br><span class="line">        pygame.display.update()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    def Reset(self):</span><br><span class="line">        self.map = [[0 <span class="keyword">for</span> y <span class="keyword">in</span> range(0, self.SIZE)] <span class="keyword">for</span> x <span class="keyword">in</span> range(0, self.SIZE)]</span><br><span class="line">        self.moveStack = []</span><br><span class="line">        pygame.init()</span><br><span class="line">        self.screen = pygame.display.set_mode((self.WINDOW_RANGE, self.WINDOW_RANGE))</span><br><span class="line">        pygame.display.set_caption(self.TITLE)</span><br><span class="line">        self.Draw_Map()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制棋盘</span></span><br><span class="line">    def Draw_Map(self):</span><br><span class="line">        <span class="comment"># 背景图</span></span><br><span class="line">        self.screen.blit(pygame.image.load(r<span class="string">&quot;pic/checkerboard.jpg&quot;</span>), (0, 0))</span><br><span class="line">        <span class="comment"># 绘制棋盘行和列</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> range(self.SIZE):</span><br><span class="line">            pygame.draw.line(self.screen, BLACK, [self.BORDER_WIDTH, self.BORDER_WIDTH + self.UNIT * item],</span><br><span class="line">                             [self.BORDER_WIDTH + self.UNIT * (self.SIZE - 1), self.BORDER_WIDTH + self.UNIT * item], 1)</span><br><span class="line">            pygame.draw.line(self.screen, BLACK, [self.BORDER_WIDTH + self.UNIT * item, self.BORDER_WIDTH],</span><br><span class="line">                             [self.BORDER_WIDTH + self.UNIT * item, self.BORDER_WIDTH + self.UNIT * (self.SIZE - 1)], 1)</span><br><span class="line">        <span class="comment"># 绘制棋子</span></span><br><span class="line">        mst = self.moveStack</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> mst:</span><br><span class="line">            x = self.BORDER_WIDTH + item[1] * self.UNIT</span><br><span class="line">            y = self.BORDER_WIDTH + item[2] * self.UNIT</span><br><span class="line">            mst_color = BLACK <span class="keyword">if</span> item[0] == 1 <span class="keyword">else</span> WHITE</span><br><span class="line">            pygame.draw.circle(self.screen, mst_color, [x, y], int(self.UNIT / 2.5))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘画出玩家落子（也用于画出强化学习互博的落子）</span></span><br><span class="line">    def Player_Move(self, pos, turn=1, who=<span class="string">&#x27;EL&#x27;</span>):</span><br><span class="line">        <span class="keyword">if</span> who == <span class="string">&#x27;player&#x27;</span>:  <span class="comment"># 玩家落子</span></span><br><span class="line">            <span class="comment"># 落子位置为鼠标点击处最近的落棋点</span></span><br><span class="line">            s_x = round((pos[0] - self.BORDER_WIDTH) / self.UNIT)</span><br><span class="line">            s_y = round((pos[1] - self.BORDER_WIDTH) / self.UNIT)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 强化学习落子</span></span><br><span class="line">            s_x = pos[0]</span><br><span class="line">            s_y = pos[1]</span><br><span class="line">        <span class="comment"># 判断落子位置是否合法</span></span><br><span class="line">        <span class="keyword">if</span> 0 &lt;= s_x &lt;= 14 and 0 &lt;= s_y &lt;= 14:</span><br><span class="line">            move_right = self.player_move(s_x, s_y, turn)</span><br><span class="line">            <span class="keyword">if</span> move_right == False:  <span class="comment"># 已经有棋子落在该位置了</span></span><br><span class="line">                <span class="built_in">return</span> False</span><br><span class="line">            <span class="comment"># 鼠标点击为合法位置，绘制棋子</span></span><br><span class="line">            p_x = self.BORDER_WIDTH + self.UNIT * s_x</span><br><span class="line">            p_y = self.BORDER_WIDTH + self.UNIT * s_y</span><br><span class="line">            <span class="keyword">if</span> turn == 1 or turn == 0:</span><br><span class="line">                pygame.draw.circle(self.screen, BLACK, [p_x, p_y], int(self.UNIT / 2.5))</span><br><span class="line">            <span class="keyword">elif</span> turn == -1:</span><br><span class="line">                pygame.draw.circle(self.screen, WHITE, [p_x, p_y], int(self.UNIT / 2.5))</span><br><span class="line">            pygame.display.update()  <span class="comment"># 绘制屏幕内容</span></span><br><span class="line">            <span class="built_in">return</span> True</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于强化学习或MGT或GA与玩家下棋</span></span><br><span class="line">    def AI_Move(self, ai=<span class="string">&#x27;MGT&#x27;</span>):</span><br><span class="line">        self.ai_move(ai)</span><br><span class="line">        _, s_x, s_y = self.moveStack[-1]</span><br><span class="line">        p_x = self.BORDER_WIDTH + self.UNIT * s_x</span><br><span class="line">        p_y = self.BORDER_WIDTH + self.UNIT * s_y</span><br><span class="line">        pygame.draw.circle(self.screen, WHITE, [p_x, p_y], int(self.UNIT / 2.5))</span><br><span class="line">        pygame.display.update()  <span class="comment"># 绘制屏幕内容</span></span><br><span class="line"></span><br><span class="line">    def Win(self, winner=<span class="string">&#x27;MGT&#x27;</span>):</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        <span class="keyword">if</span> winner == <span class="string">&#x27;player&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;玩家获胜!&quot;</span>)</span><br><span class="line">            self.screen.blit(pygame.transform.scale(pygame.image.load(r<span class="string">&quot;pic/palyer_win.jpg&quot;</span>), (520, 520)), (0, 0))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> winner == <span class="string">&#x27;MGT&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;AI获胜!&quot;</span>)</span><br><span class="line">            self.screen.blit(pygame.transform.scale(pygame.image.load(r<span class="string">&quot;pic/MGTwin.jpg&quot;</span>), (520, 520)), (0, 0))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> winner == <span class="string">&#x27;DQN&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;强化学习获胜！&quot;</span>)</span><br><span class="line">            self.screen.blit(pygame.transform.scale(pygame.image.load(r<span class="string">&quot;pic/RLwin.jpg&quot;</span>), (520, 520)), (0, 0))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> winner == <span class="string">&#x27;GA&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;进化网络获胜！&quot;</span>)</span><br><span class="line">            self.screen.blit(pygame.transform.scale(pygame.image.load(r<span class="string">&quot;pic/GAwin.jpg&quot;</span>), (520, 520)), (0, 0))</span><br><span class="line"></span><br><span class="line">        pygame.display.update()</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line">    def Start_MGT_or_RL_or_GA(self, ai=<span class="string">&#x27;MGT&#x27;</span>):</span><br><span class="line">        self.Draw_Map()</span><br><span class="line">        <span class="keyword">while</span> True:</span><br><span class="line">            <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">                <span class="keyword">if</span> event.type == QUIT:  <span class="comment"># 退出事件</span></span><br><span class="line">                    pygame.quit()</span><br><span class="line">                    sys.exit()</span><br><span class="line">                <span class="keyword">if</span> event.type == MOUSEBUTTONUP:  <span class="comment"># 落子事件</span></span><br><span class="line">                    x = event.pos[0]</span><br><span class="line">                    y = event.pos[1]</span><br><span class="line">                    move_right = self.Player_Move(event.pos, who=<span class="string">&#x27;player&#x27;</span>)</span><br><span class="line">                    <span class="keyword">if</span> move_right == False:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;move wrong&quot;</span>)</span><br><span class="line">                        <span class="built_in">continue</span></span><br><span class="line">                    win = self.check_result()</span><br><span class="line">                    <span class="keyword">if</span> win == 1 or win == 2:</span><br><span class="line">                        self.Win(<span class="string">&#x27;player&#x27;</span>)</span><br><span class="line">                        <span class="built_in">return</span></span><br><span class="line">                    self.AI_Move(ai)</span><br><span class="line">                    win = self.check_result()</span><br><span class="line">                    <span class="keyword">if</span> win == -1 or win == 2:</span><br><span class="line">                        self.Win(ai)</span><br><span class="line">                        <span class="built_in">return</span></span><br><span class="line">            pygame.display.update()  <span class="comment"># 绘制屏幕内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练强化学习的界面</span></span><br><span class="line">    def RL_vs_RL(self, rounds=0):</span><br><span class="line">        <span class="keyword">while</span> True:</span><br><span class="line">            <span class="comment"># 强化学习走一步</span></span><br><span class="line">            x, y = self.RL_AI.find_best_pos(self.map, 1)</span><br><span class="line">            self.Player_Move((x, y), 1)</span><br><span class="line">            win = self.check_result()</span><br><span class="line">            <span class="keyword">if</span> win != 0:</span><br><span class="line">                s1, s2, r, len1 = self.RL_AI.generate_states_and_rewards(self.moveStack)</span><br><span class="line">                self.RL_AI.learn(s1, s2, r, len1)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Round: &quot;</span> + str(rounds) + <span class="string">&quot; ,black RL win&quot;</span>)</span><br><span class="line">                <span class="built_in">return</span></span><br><span class="line">            <span class="comment"># 另一个强化学习走一步</span></span><br><span class="line">            x, y = self.RL_AI.find_best_pos(self.map, -1)</span><br><span class="line">            self.Player_Move((x, y), -1)</span><br><span class="line">            win = self.check_result()</span><br><span class="line">            <span class="keyword">if</span> win != 0:</span><br><span class="line">                s1, s2, r, len1 = self.RL_AI.generate_states_and_rewards(self.moveStack)</span><br><span class="line">                self.RL_AI.learn(s1, s2, r, len1)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Round: &quot;</span> + str(rounds) + <span class="string">&quot; ,white RL win&quot;</span>)</span><br><span class="line">                <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">            pygame.display.update()  <span class="comment"># 绘制屏幕内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主界面</span></span><br><span class="line">    def Start(self):</span><br><span class="line">        <span class="keyword">while</span> True:</span><br><span class="line">            <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">                <span class="keyword">if</span> event.type == QUIT:  <span class="comment"># 退出事件</span></span><br><span class="line">                    pygame.quit()</span><br><span class="line">                    sys.exit()</span><br><span class="line">                <span class="keyword">if</span> event.type == MOUSEBUTTONUP:  <span class="comment"># 落子事件</span></span><br><span class="line">                    x = event.pos[0]</span><br><span class="line">                    y = event.pos[1]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 点击第一个按钮，先观察未经过训练的强化学习自己训练10局，再观察经过训练的强化学习自己训练10局</span></span><br><span class="line">                    <span class="keyword">if</span> self.BTN_RLvsRL_X[0] &lt; x &lt; self.BTN_RLvsRL_X[1] and \</span><br><span class="line">                            self.BTN_RLvsRL_Y[0] &lt; y &lt; self.BTN_RLvsRL_Y[1]:</span><br><span class="line">                        <span class="comment"># 未经过训练的强化学习自己训练10局</span></span><br><span class="line">                        self.screen.blit(</span><br><span class="line">                            pygame.transform.scale(pygame.image.load(r<span class="string">&quot;pic/RLwithout_train.jpg&quot;</span>), (520, 520)), (0, 0))</span><br><span class="line">                        pygame.display.update()</span><br><span class="line">                        time.sleep(1.5)</span><br><span class="line">                        round = 0</span><br><span class="line">                        self.Draw_Map()</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> range(10):</span><br><span class="line">                            self.RL_AI.learn_step_counter = round</span><br><span class="line">                            self.RL_vs_RL(round)</span><br><span class="line">                            <span class="comment"># pygame.image.save(self.screen, &quot;a&quot; + str(i) + &quot;.jpg&quot;)</span></span><br><span class="line">                            self.Reset()</span><br><span class="line">                            round += 1</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 经过训练的强化学习自己训练10局</span></span><br><span class="line">                        self.screen.blit(</span><br><span class="line">                            pygame.transform.scale(pygame.image.load(r<span class="string">&quot;pic/RL_train.jpg&quot;</span>), (520, 520)), (0, 0))</span><br><span class="line">                        pygame.display.update()</span><br><span class="line">                        time.sleep(1.5)</span><br><span class="line">                        round = 38500</span><br><span class="line">                        self.Draw_Map()</span><br><span class="line">                        self.RL_AI.target_net.load_state_dict(torch.load(<span class="string">&quot;weight/task4_DQN_38500.pth&quot;</span>))</span><br><span class="line">                        self.RL_AI.eval_net.load_state_dict(torch.load(<span class="string">&quot;weight/task4_DQN_38500.pth&quot;</span>))</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> range(10):</span><br><span class="line">                            self.RL_AI.learn_step_counter = round</span><br><span class="line">                            self.RL_vs_RL(round)</span><br><span class="line">                            <span class="comment"># pygame.image.save(self.screen, &quot;ajhsaj&quot; + str(i) + &quot;.jpg&quot;)</span></span><br><span class="line">                            self.Reset()</span><br><span class="line">                            round += 1</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 点击第二个按钮，博弈树与玩家下棋</span></span><br><span class="line">                    <span class="keyword">elif</span> self.BTN_MGT_AI_X[0] &lt; x &lt; self.BTN_MGT_AI_X[1] and \</span><br><span class="line">                            self.BTN_MGT_AI_Y[0] &lt; y &lt; self.BTN_MGT_AI_Y[1]:</span><br><span class="line">                        self.Start_MGT_or_RL_or_GA(<span class="string">&quot;MGT&quot;</span>)</span><br><span class="line">                        <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 点击第三个按钮，GA训练的网络与玩家下棋</span></span><br><span class="line">                    <span class="keyword">elif</span> self.BTN_GA_AI_X[0] &lt; x &lt; self.BTN_GA_AI_X[1] and \</span><br><span class="line">                            self.BTN_GA_AI_Y[0] &lt; y &lt; self.BTN_GA_AI_Y[1]:</span><br><span class="line">                        self.Start_MGT_or_RL_or_GA(<span class="string">&quot;GA&quot;</span>)</span><br><span class="line">                        <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 点击第四个按钮，训练好的强化学习与玩家下棋</span></span><br><span class="line">                    <span class="keyword">elif</span> self.BTN_RL_AI_X[0] &lt; x &lt; self.BTN_RL_AI_X[1] and \</span><br><span class="line">                            self.BTN_RL_AI_Y[0] &lt; y &lt; self.BTN_RL_AI_Y[1]:</span><br><span class="line">                        self.RL_AI.target_net.load_state_dict(torch.load(<span class="string">&quot;weight/task4_DQN_38500.pth&quot;</span>))</span><br><span class="line">                        self.RL_AI.eval_net.load_state_dict(torch.load(<span class="string">&quot;weight/task4_DQN_38500.pth&quot;</span>))</span><br><span class="line">                        self.Start_MGT_or_RL_or_GA(<span class="string">&quot;DQN&quot;</span>)</span><br><span class="line">                        <span class="built_in">return</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="built_in">continue</span></span><br><span class="line">            pygame.display.update()  <span class="comment"># 绘制屏幕内容</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;博弈树AI&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">AI_SEARCH_DEEP = 4  <span class="comment"># 搜索深度</span></span><br><span class="line">AI_SEARCH_RADIUS = 1  <span class="comment"># 在已经下的棋周围一圈的位置搜索可下棋位置（忽略太远的位置）</span></span><br><span class="line">AI_LIMITED_MOVE_NUM = 20  <span class="comment"># 最多搜索的位置</span></span><br><span class="line">SCORE_MAX = 0x7fffffff  <span class="comment"># 正无穷</span></span><br><span class="line">SCORE_MIN = -0x7fffffff  <span class="comment"># 负无穷</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7种有效棋形 没有为0 共有棋形数CHESS_TYPE_NUM = 8</span></span><br><span class="line">CHESS_TYPE_NUM = 8</span><br><span class="line">NONE = 0  <span class="comment"># 无棋形</span></span><br><span class="line">FIVE = 1  <span class="comment"># 连五</span></span><br><span class="line">FOUR = 2  <span class="comment"># 活四</span></span><br><span class="line">THREE = 3  <span class="comment"># 活三</span></span><br><span class="line">TWO = 4  <span class="comment"># 活二</span></span><br><span class="line">SFOUR = 5  <span class="comment"># 冲四</span></span><br><span class="line">STHREE = 6  <span class="comment"># 眠三</span></span><br><span class="line">STWO = 7  <span class="comment"># 眠二</span></span><br><span class="line"></span><br><span class="line">SCORE_FIVE, SCORE_FOUR, SCORE_SFOUR = 100000, 10000, 1000</span><br><span class="line">SCORE_THREE, SCORE_STHREE, SCORE_TWO, SCORE_STWO = 100, 10, 8, 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 博弈搜索算法(Minimax Game Tree)</span></span><br><span class="line">class MGT_AI():</span><br><span class="line">    def __init__(self, mapsize):</span><br><span class="line">        self.len = mapsize</span><br><span class="line">        <span class="comment"># record 记录每个棋子横、纵、左斜、右斜这四个方向是否被检测过</span></span><br><span class="line">        self.record = [[[0 <span class="keyword">for</span> z <span class="keyword">in</span> range(4)] <span class="keyword">for</span> y <span class="keyword">in</span> range(mapsize)] <span class="keyword">for</span> x <span class="keyword">in</span> range(mapsize)]</span><br><span class="line">        <span class="comment"># count 记录黑棋白棋棋形个数之和 count[0]不计数，只有count[1]和count[-1](count[2])计数 ecount大概估计中使用</span></span><br><span class="line">        self.count = [[0 <span class="keyword">for</span> x <span class="keyword">in</span> range(CHESS_TYPE_NUM)] <span class="keyword">for</span> y <span class="keyword">in</span> range(3)]</span><br><span class="line">        self.ecount = [[0 <span class="keyword">for</span> x <span class="keyword">in</span> range(CHESS_TYPE_NUM)] <span class="keyword">for</span> y <span class="keyword">in</span> range(3)]</span><br><span class="line">        <span class="comment"># best_move 保存得分最高的位置坐标</span></span><br><span class="line">        self.best_move = None</span><br><span class="line">        <span class="comment"># 搜索的最大深度</span></span><br><span class="line">        self.max_depth = AI_SEARCH_DEEP</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对于具体的一条线，以选取点为中心，取该方向前四点和后四点组成长为9的列表</span></span><br><span class="line">    def Get_line(self, map, x, y, direction, turn):</span><br><span class="line">        line = [0 <span class="keyword">for</span> i <span class="keyword">in</span> range(9)]</span><br><span class="line">        tmp_x = x + (-5 * direction[0])</span><br><span class="line">        tmp_y = y + (-5 * direction[1])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(9):</span><br><span class="line">            tmp_x += direction[0]</span><br><span class="line">            tmp_y += direction[1]</span><br><span class="line">            <span class="keyword">if</span> 0 &lt;= tmp_x &lt; self.len and 0 &lt;= tmp_y &lt; self.len:</span><br><span class="line">                line[i] = map[tmp_x][tmp_y]</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 如果线上的位置超越了棋盘范围，则将这个位置设置为对手的值</span></span><br><span class="line">                line[i] = -turn</span><br><span class="line">        <span class="built_in">return</span> line</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 标记已经检测过，需要跳过的棋子</span></span><br><span class="line">    def Set_record(self, x, y, left, right, dirction_index, direction):</span><br><span class="line">        tmp_x = x + (-5 + left) * direction[0]</span><br><span class="line">        tmp_y = y + (-5 + left) * direction[1]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right + 1):</span><br><span class="line">            tmp_x += direction[0]</span><br><span class="line">            tmp_y += direction[1]</span><br><span class="line">            self.record[tmp_x][tmp_y][dirction_index] = 1</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 评价该点当前方向上的分数，并存入count数组之中</span></span><br><span class="line">    def Analysis_line(self, map, x, y, direction_index, direction, turn, count):</span><br><span class="line">        line = self.Get_line(map, x, y, direction, turn)  <span class="comment"># 得到该方向上以当前棋子（x,y）为中心的9个棋子列表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># left_idx和right_idx表示turn方棋手的棋已经连成的范围</span></span><br><span class="line">        left_idx = right_idx = 4</span><br><span class="line">        <span class="keyword">while</span> right_idx &lt; 8:</span><br><span class="line">            <span class="keyword">if</span> line[right_idx + 1] != turn:</span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">            right_idx += 1</span><br><span class="line">        <span class="keyword">while</span> left_idx &gt; 0:</span><br><span class="line">            <span class="keyword">if</span> line[left_idx - 1] != turn:</span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">            left_idx -= 1</span><br><span class="line"></span><br><span class="line">        <span class="comment"># left_idx和right_idx表示turn方棋手的棋加上空位可能连成的范围</span></span><br><span class="line">        left_range, right_range = left_idx, right_idx</span><br><span class="line">        <span class="keyword">while</span> right_range &lt; 8:</span><br><span class="line">            <span class="keyword">if</span> line[right_range + 1] == -turn:</span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">            right_range += 1</span><br><span class="line">        <span class="keyword">while</span> left_range &gt; 0:</span><br><span class="line">            <span class="keyword">if</span> line[left_range - 1] == -turn:</span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">            left_range -= 1</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果可连的范围小于5，那么以当前棋子为中心的该方向线上的所有可连位置的棋子都是没有棋形</span></span><br><span class="line">        <span class="keyword">if</span> right_range - left_range + 1 &lt; 5:</span><br><span class="line">            self.Set_record(x, y, left_range, right_range, direction_index, direction)</span><br><span class="line">            <span class="built_in">return</span> NONE</span><br><span class="line"></span><br><span class="line">        m_range = right_idx - left_idx + 1  <span class="comment"># 当前turn的棋子的相连个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接下来用M表示当前turn的棋子，P表示对方棋子，X表示空位</span></span><br><span class="line">        <span class="keyword">if</span> m_range &gt;= 5:</span><br><span class="line">            count[FIVE] += 1</span><br><span class="line">            self.Set_record(x, y, left_idx, right_idx, direction_index, direction)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 四连有以下几种可能  Live Four（活四）：XMMMMX    Chong Four（冲四）：XMMMMMP,PMMMMX</span></span><br><span class="line">        <span class="keyword">if</span> m_range == 4:</span><br><span class="line">            <span class="keyword">if</span> line[left_idx - 1] == 0 and line[right_idx + 1] == 0:</span><br><span class="line">                count[FOUR] += 1</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count[SFOUR] += 1</span><br><span class="line">            self.Set_record(x, y, left_idx, right_idx, direction_index, direction)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 三连有以下几种可能  Chong Four（冲四）：MXMMM,MMMXM（两种类型可以同时存在）   Live Three：XMMMXX,XXMMMX   Sleep Three:PMMMX,XMMMP,PXMMMXP</span></span><br><span class="line">        <span class="keyword">if</span> m_range == 3:</span><br><span class="line">            <span class="keyword">if</span> (line[left_idx - 1] == 0 and line[left_idx - 2] == turn) or (</span><br><span class="line">                    line[right_idx + 1] == 0 and line[right_idx + 2] == turn):</span><br><span class="line">                <span class="keyword">if</span> line[left_idx - 1] == 0 and line[left_idx - 2] == turn:  <span class="comment"># MXMMM</span></span><br><span class="line">                    count[SFOUR] += 1</span><br><span class="line">                    self.Set_record(x, y, left_idx - 2, right_idx, direction_index, direction)</span><br><span class="line">                <span class="keyword">if</span> line[right_idx + 1] == 0 and line[right_idx + 2] == turn:  <span class="comment"># MMMXM</span></span><br><span class="line">                    count[SFOUR] += 1</span><br><span class="line">                    self.Set_record(x, y, left_idx, right_idx + 2, direction_index, direction)</span><br><span class="line">            <span class="keyword">elif</span> line[left_idx - 1] == 0 and line[right_idx + 1] == 0:</span><br><span class="line">                <span class="keyword">if</span> right_range - left_range + 1 &gt; 5:  <span class="comment"># XMMMXX,XXMMMX</span></span><br><span class="line">                    count[THREE] += 1</span><br><span class="line">                    self.Set_record(x, y, left_idx, right_idx, direction_index, direction)</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># PXMMMXP</span></span><br><span class="line">                    count[STHREE] += 1</span><br><span class="line">                    self.Set_record(x, y, left_idx, right_idx, direction_index, direction)</span><br><span class="line">            <span class="keyword">elif</span> line[left_idx - 1] == 0 or line[right_idx + 1] == 0:  <span class="comment"># PMMMX,XMMMP</span></span><br><span class="line">                count[STHREE] += 1</span><br><span class="line">                self.Set_record(x, y, left_idx, right_idx, direction_index, direction)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二连有以下几种可能 Chong Four：MMXMM（在record机制下，只需检查右边）   Live Three：XMXMMX,XMMXMX（可能同时存在）</span></span><br><span class="line">        <span class="comment"># Sleep Three：PMXMMX,XMXMMP,PMMXMX,XMMXMP    Live Two：XMMX   Sleep Two：PMMX,XMMP</span></span><br><span class="line">        <span class="keyword">if</span> m_range == 2:</span><br><span class="line">            <span class="keyword">if</span> line[right_idx + 1] == 0 and line[right_idx + 2] == turn and line[right_idx + 3] == turn:  <span class="comment"># MMXMM</span></span><br><span class="line">                count[SFOUR] += 1</span><br><span class="line">                self.Set_record(x, y, left_idx, right_idx + 3, direction_index, direction)</span><br><span class="line">            <span class="keyword">if</span> line[left_idx - 1] == 0 and line[right_idx + 1] == 0:</span><br><span class="line">                <span class="keyword">if</span> line[left_idx - 2] == turn:</span><br><span class="line">                    <span class="keyword">if</span> line[left_idx - 3] == 0:  <span class="comment"># XMXMMX</span></span><br><span class="line">                        count[THREE] += 1</span><br><span class="line">                    <span class="keyword">elif</span> line[left_idx - 3] == -turn:  <span class="comment"># PMXMMX</span></span><br><span class="line">                        count[STHREE] += 1</span><br><span class="line">                    self.Set_record(x, y, left_idx - 2, right_idx, direction_index, direction)</span><br><span class="line">                <span class="keyword">if</span> line[right_idx + 2] == turn:</span><br><span class="line">                    <span class="keyword">if</span> line[right_idx + 3] == 0:  <span class="comment"># XMMXMX</span></span><br><span class="line">                        count[THREE] += 1</span><br><span class="line">                    <span class="keyword">elif</span> line[right_idx + 3] == -turn:  <span class="comment"># XMMXMP</span></span><br><span class="line">                        count[STHREE] += 1</span><br><span class="line">                    self.Set_record(x, y, left_idx, right_idx + 2, direction_index, direction)</span><br><span class="line">                <span class="keyword">if</span> line[left_idx - 2] != turn and line[right_idx + 2] != turn:  <span class="comment"># XMMX</span></span><br><span class="line">                    count[TWO] += 1</span><br><span class="line">                    self.Set_record(x, y, left_idx, right_idx, direction_index, direction)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> line[left_idx - 2] == turn or line[right_idx + 2] == turn:</span><br><span class="line">                    <span class="keyword">if</span> line[left_idx - 2] == turn:  <span class="comment"># XMXMMP</span></span><br><span class="line">                        count[STHREE] += 1</span><br><span class="line">                        self.Set_record(x, y, left_idx - 2, right_idx, direction_index, direction)</span><br><span class="line">                    <span class="keyword">if</span> line[right_idx + 2] == turn:  <span class="comment"># PMMXMX</span></span><br><span class="line">                        count[STHREE] += 1</span><br><span class="line">                        self.Set_record(x, y, left_idx, right_idx + 2, direction_index, direction)</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># PMMX,XMMP</span></span><br><span class="line">                    count[STWO] += 1</span><br><span class="line">                    self.Set_record(x, y, left_idx, right_idx, direction_index, direction)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 一连有以下几种可能 Live Two:XMXMX,XMXXMX（在record机制下，只需检查右边） Sleep Two:PMXMX.XMXMP</span></span><br><span class="line">        <span class="keyword">if</span> m_range == 1:</span><br><span class="line">            <span class="keyword">if</span> line[left_idx - 1] == 0 and line[right_idx + 1] == 0:</span><br><span class="line">                <span class="keyword">if</span> (line[right_idx + 2] == 0 and line[right_idx + 3] == turn and line[right_idx + 4] == 0) or (</span><br><span class="line">                        line[right_idx + 2] == turn and line[right_idx + 3] == 0):  <span class="comment"># XMXXMX,XMXMX</span></span><br><span class="line">                    count[TWO] += 1</span><br><span class="line">                    self.Set_record(x, y, left_idx, right_idx + 3, direction_index, direction)</span><br><span class="line">            <span class="keyword">elif</span> line[left_idx - 2] == turn:  <span class="comment"># XMXMP</span></span><br><span class="line">                count[STWO] += 1</span><br><span class="line">                self.Set_record(x, y, left_idx - 2, right_idx, direction_index, direction)</span><br><span class="line">            <span class="keyword">elif</span> line[right_idx + 2] == turn:  <span class="comment"># PMXMX</span></span><br><span class="line">                count[STWO] += 1</span><br><span class="line">                self.Set_record(x, y, left_idx, right_idx + 2, direction_index, direction)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> NONE</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在该点的四个方向计算棋形并存入count中</span></span><br><span class="line">    def Evaluate_point(self, map, x, y, turn, count=None):</span><br><span class="line">        directions = [(1, 0), (0, 1), (1, 1), (-1, 1)]  <span class="comment"># 检查每个棋子四个方向的直线</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(4):</span><br><span class="line">            <span class="keyword">if</span> self.record[x][y][i] == 0:</span><br><span class="line">                <span class="comment"># 在python中，如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值</span></span><br><span class="line">                self.Analysis_line(map, x, y, i, directions[i], turn, count)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得当前棋局的分数</span></span><br><span class="line">    def Evaluate(self, map, turn):</span><br><span class="line">        <span class="comment"># 每次评估前，先清空record和count</span></span><br><span class="line">        self.record = [[[0 <span class="keyword">for</span> z <span class="keyword">in</span> range(4)] <span class="keyword">for</span> y <span class="keyword">in</span> range(self.len)] <span class="keyword">for</span> x <span class="keyword">in</span> range(self.len)]</span><br><span class="line">        self.count = [[0 <span class="keyword">for</span> x <span class="keyword">in</span> range(CHESS_TYPE_NUM)] <span class="keyword">for</span> y <span class="keyword">in</span> range(3)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对棋盘上的每个点计算分数</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(self.len):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(self.len):</span><br><span class="line">                <span class="keyword">if</span> map[x][y] == turn:</span><br><span class="line">                    self.Evaluate_point(map, x, y, turn, self.count[turn])</span><br><span class="line">                <span class="keyword">elif</span> map[x][y] == -turn:</span><br><span class="line">                    self.Evaluate_point(map, x, y, -turn, self.count[-turn])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按count中的棋形数打分，count[turn]是己方棋型数，count[-turn]是对方棋形数，返回的分数为己方分-对方分</span></span><br><span class="line">        <span class="keyword">if</span> self.count[turn][FIVE] &gt; 0:</span><br><span class="line">            <span class="built_in">return</span> SCORE_FIVE</span><br><span class="line">        <span class="keyword">if</span> self.count[-turn][FIVE] &gt; 0:</span><br><span class="line">            <span class="built_in">return</span> -SCORE_FIVE</span><br><span class="line">        <span class="keyword">if</span> self.count[turn][SFOUR] &gt;= 2 or self.count[turn][FOUR] &gt; 0:</span><br><span class="line">            <span class="built_in">return</span> 9050</span><br><span class="line">        <span class="keyword">if</span> self.count[turn][SFOUR] &gt;= 1:</span><br><span class="line">            <span class="built_in">return</span> 9040</span><br><span class="line">        <span class="keyword">if</span> self.count[-turn][SFOUR] &gt;= 2 or self.count[-turn][FOUR] &gt; 0:</span><br><span class="line">            <span class="built_in">return</span> -9030</span><br><span class="line">        <span class="keyword">if</span> self.count[-turn][SFOUR] == 1 and self.count[-turn][THREE] &gt; 0:</span><br><span class="line">            <span class="built_in">return</span> -9020</span><br><span class="line">        <span class="keyword">if</span> self.count[turn][THREE] &gt; 0 and self.count[-turn][SFOUR] == 0:</span><br><span class="line">            <span class="built_in">return</span> 9010</span><br><span class="line">        <span class="keyword">if</span> self.count[-turn][THREE] &gt; 1 and self.count[turn][THREE] == 0 and self.count[turn][STHREE] == 0:</span><br><span class="line">            <span class="built_in">return</span> -9000</span><br><span class="line">        oscore = mscore = 0</span><br><span class="line">        <span class="keyword">if</span> self.count[-turn][SFOUR] &gt; 0:</span><br><span class="line">            oscore += 400</span><br><span class="line">        <span class="keyword">if</span> self.count[turn][THREE] &gt; 1:</span><br><span class="line">            mscore += 500</span><br><span class="line">        <span class="keyword">elif</span> self.count[turn][THREE] == 1:</span><br><span class="line">            mscore += 100</span><br><span class="line">        <span class="keyword">if</span> self.count[-turn][THREE] &gt; 1:</span><br><span class="line">            mscore += 2000</span><br><span class="line">        <span class="keyword">elif</span> self.count[-turn][THREE] == 1:</span><br><span class="line">            mscore += 400</span><br><span class="line">        mscore += self.count[turn][STHREE] * 10 + self.count[turn][TWO] * 6 + self.count[turn][STWO] * 2</span><br><span class="line">        oscore += self.count[-turn][STHREE] * 10 + self.count[-turn][TWO] * 6 + self.count[-turn][STWO] * 2</span><br><span class="line">        <span class="built_in">return</span> mscore - oscore</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查看在该位置在指定半径内（这里设为1）有没有棋子</span></span><br><span class="line">    def Has_neighbor(self, map, x, y, radius=AI_SEARCH_RADIUS):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x - radius, x + radius + 1):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(y - radius, y + radius + 1):</span><br><span class="line">                <span class="keyword">if</span> 0 &lt;= i &lt; self.len and 0 &lt;= j &lt; self.len:</span><br><span class="line">                    <span class="keyword">if</span> map[i][j] != 0:</span><br><span class="line">                        <span class="built_in">return</span> True</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算ecount的分数</span></span><br><span class="line">    def Estimate_score(self, ecount):</span><br><span class="line">        <span class="keyword">if</span> ecount[FIVE] &gt; 0:</span><br><span class="line">            <span class="built_in">return</span> SCORE_FIVE</span><br><span class="line">        <span class="keyword">if</span> ecount[FOUR] &gt; 0:</span><br><span class="line">            <span class="built_in">return</span> SCORE_FOUR</span><br><span class="line"></span><br><span class="line">        score = 0</span><br><span class="line">        <span class="keyword">if</span> ecount[SFOUR] &gt; 1 or (ecount[SFOUR] == 1 and ecount[THREE] &gt; 0):  <span class="comment"># 一个冲四且没有活三的分数应该很低，设为和活三一样的分数</span></span><br><span class="line">            score += ecount[SFOUR] * SCORE_SFOUR</span><br><span class="line">        <span class="keyword">elif</span> ecount[SFOUR] == 1:</span><br><span class="line">            score += SCORE_THREE</span><br><span class="line">        <span class="keyword">if</span> ecount[THREE] &gt; 1:</span><br><span class="line">            score += 5 * SCORE_THREE</span><br><span class="line">        <span class="keyword">elif</span> ecount[THREE] == 1:</span><br><span class="line">            score += SCORE_THREE</span><br><span class="line">        score += ecount[STHREE] * SCORE_STHREE + ecount[TWO] * SCORE_TWO + ecount[STWO] * SCORE_STWO</span><br><span class="line">        <span class="built_in">return</span> score</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 大概估计该点的分数</span></span><br><span class="line">    def Estimate_point(self, map, x, y, turn):</span><br><span class="line">        self.ecount = [[0 <span class="keyword">for</span> x <span class="keyword">in</span> range(CHESS_TYPE_NUM)] <span class="keyword">for</span> y <span class="keyword">in</span> range(3)]</span><br><span class="line">        directions = [(1, 0), (0, 1), (1, 1), (1, -1)]</span><br><span class="line">        map[x][y] = turn</span><br><span class="line">        self.Evaluate_point(map, x, y, turn, self.ecount[turn])</span><br><span class="line">        map[x][y] = -turn</span><br><span class="line">        self.Evaluate_point(map, x, y, -turn, self.ecount[-turn])</span><br><span class="line">        map[x][y] = 0</span><br><span class="line">        mscore = self.Estimate_score(self.ecount[turn])</span><br><span class="line">        oscore = self.Estimate_score(self.ecount[-turn])</span><br><span class="line">        <span class="built_in">return</span> mscore, oscore</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 寻找当前棋盘上棋子周围的位置中可下棋位置</span></span><br><span class="line">    def Generate_move(self, map, turn, <span class="built_in">limit</span>=AI_LIMITED_MOVE_NUM):</span><br><span class="line">        <span class="comment"># 如果有可以连五、活四或冲四的位置，则只搜索这些位置。由于不光要走自己的，也要防对手的，所以己方和对方的分数取最大值</span></span><br><span class="line">        moves, fives, fours, sfours = [], [], [], []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(self.len):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(self.len):</span><br><span class="line">                <span class="keyword">if</span> map[x][y] == 0 and self.Has_neighbor(map, x, y):  <span class="comment"># Has_neighbor避免搜索一些离当前棋局过远的位置，减少搜索时间</span></span><br><span class="line">                    mscore, oscore = self.Estimate_point(map, x, y, turn)</span><br><span class="line">                    point = (max(mscore, oscore), x, y)</span><br><span class="line">                    moves.append(point)</span><br><span class="line">                    <span class="keyword">if</span> max(mscore, oscore) &gt;= SCORE_FIVE:</span><br><span class="line">                        fives.append(point)</span><br><span class="line">                        <span class="built_in">return</span> fives</span><br><span class="line">                    <span class="keyword">if</span> max(mscore, oscore) &gt;= SCORE_FOUR:</span><br><span class="line">                        fours.append(point)</span><br><span class="line">                    <span class="keyword">elif</span> max(mscore, oscore) &gt;= SCORE_SFOUR:</span><br><span class="line">                        sfours.append(point)</span><br><span class="line">        <span class="keyword">if</span> len(fours) &gt; 0:</span><br><span class="line">            <span class="built_in">return</span> fours</span><br><span class="line">        <span class="keyword">if</span> len(sfours) &gt; 0:</span><br><span class="line">            <span class="built_in">return</span> sfours</span><br><span class="line">        <span class="comment"># # 如果没有以上三种棋形，则只考虑分数最高的有限步</span></span><br><span class="line">        moves.sort(reverse=True)</span><br><span class="line">        <span class="keyword">if</span> self.max_depth &gt; 2 and len(moves) &gt; <span class="built_in">limit</span>:</span><br><span class="line">            moves = moves[:<span class="built_in">limit</span>]</span><br><span class="line">        <span class="built_in">return</span> moves</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 极大极小深度优先搜索</span></span><br><span class="line">    def DFS(self, map, turn, depth=AI_SEARCH_DEEP, alpha=SCORE_MIN, beta=SCORE_MAX):</span><br><span class="line">        score = self.Evaluate(map, turn)  <span class="comment"># 得到当前棋局的分数</span></span><br><span class="line">        <span class="keyword">if</span> depth &lt;= 0 or abs(score) &gt;= SCORE_FIVE:  <span class="comment"># 搜索到叶子节点或者能连5的位置，不再搜索</span></span><br><span class="line">            <span class="built_in">return</span> score</span><br><span class="line"></span><br><span class="line">        moves = self.Generate_move(map, turn)  <span class="comment"># 寻找每一个可能走的位置</span></span><br><span class="line">        <span class="keyword">if</span> len(moves) == 0:  <span class="comment"># 无路可走时，不再搜索</span></span><br><span class="line">            <span class="built_in">return</span> score</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, x, y <span class="keyword">in</span> moves:  <span class="comment"># 尝试每一个可走的位置</span></span><br><span class="line">            map[x][y] = turn</span><br><span class="line">            <span class="comment"># 递归搜索，互换beta和alpha的值并取负，返回的分数也取负，可以保证score永远只更新alpha的值和剪枝条件永远为alpha &gt;= beta</span></span><br><span class="line">            score = - self.DFS(map, -turn, depth - 1, -beta, -alpha)</span><br><span class="line">            map[x][y] = 0</span><br><span class="line">            <span class="comment"># alpha-beta pruning（剪枝）</span></span><br><span class="line">            <span class="keyword">if</span> score &gt; alpha:</span><br><span class="line">                alpha = score</span><br><span class="line">                <span class="keyword">if</span> depth == AI_SEARCH_DEEP:</span><br><span class="line">                    self.best_move = (x, y)</span><br><span class="line">                <span class="keyword">if</span> alpha &gt;= beta:</span><br><span class="line">                    <span class="built_in">break</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> alpha</span><br><span class="line"></span><br><span class="line">    <span class="comment"># AI入口</span></span><br><span class="line">    def Get_best_chess(self, map, turn):</span><br><span class="line">        time1 = time.time()</span><br><span class="line">        self.best_move = None</span><br><span class="line">        score = self.DFS(map, turn)</span><br><span class="line">        x, y = self.best_move</span><br><span class="line">        time2 = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;time: %.2f   AI_pos: (%d,%d)   score: %d&#x27;</span> % ((time2 - time1), x, y, score))</span><br><span class="line">        <span class="built_in">return</span> x, y</span><br></pre></td></tr></table></figure>
<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>首先先展示一下除了alpha-beta剪枝没有经过其他搜索时间优化的AI用四层极大极小搜索是一个什么样的情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Narumi-Maria/CDN/images/pasted-18.png" alt="upload successful"></p>
<p>接着展示一下经过Has_neighbor(self, map, x, y, radius=AI_SEARCH_RADIUS)、Estimate_point、以及fives、 fours、sfours三个列表有限搜索的优化后AI搜索四层所需要的时间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Narumi-Maria/CDN/images/pasted-19.png" alt="upload successful"></p>
<p>可以看出，经过我的多个优化搜索时间的函数的作用，AI搜索四层所用的时间已经非常短了。虽然还是比不上网络的速度快，但是性能还是有了很大提升。</p>
<p>至于博弈树下棋的水平，可以运行我的程序来看。博弈树AI对于基本的连子、堵子都能够实现，能够达到一般人类棋手水平。</p>

  <p> — Dec 26, 2020</p>
  


          <div class="row mt-2">
  
    <div class="eight columns">
      <p id="madewith">Made with ❤ and
        <a class="footer-link icon" href="https://hexo.io" target="_blank" style="text-decoration: none;" rel="noreferrer" aria-label="Hexo.io">
        <svg class="hexo svg-hov" width="14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Hexo.js</title><path d="M12 .007L1.57 6.056V18.05L12 23.995l10.43-6.049V5.952L12 .007zm4.798 17.105l-.939.521-.939-.521V12.94H9.08v4.172l-.94.521-.938-.521V6.89l.939-.521.939.521v4.172h5.84V6.89l.94-.521.938.521v10.222z"/></svg>
        </a>
        
        at <a href="https://en.wikipedia.org/wiki/Earth" target="_blank" rel="noreferrer">Earth</a>.</p>
        
    </div>

    <!-- Sepcial thanks to https://simpleicons.org/ for the icons -->
    <div class="four columns mb-3 posisi" >
      
      <a class="ml-0 footer-link icon" href="https://github.com/adisaktijrs" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="GitHub">
        <svg class="github svg-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
      </a>
      

      
      <a class="ml-0 footer-link icon" href="https://linkedin.com/in/adisaktijrs" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="LinkedIn">
        <svg class="linkedin svg-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
      </a>
      

      
      <a class="ml-0 footer-link icon" href="https://twitter.com/adisaktijrs" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="Twitter">
        <svg class="twitter svg-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Twitter</title><path d="M23.954 4.569c-.885.389-1.83.654-2.825.775 1.014-.611 1.794-1.574 2.163-2.723-.951.555-2.005.959-3.127 1.184-.896-.959-2.173-1.559-3.591-1.559-2.717 0-4.92 2.203-4.92 4.917 0 .39.045.765.127 1.124C7.691 8.094 4.066 6.13 1.64 3.161c-.427.722-.666 1.561-.666 2.475 0 1.71.87 3.213 2.188 4.096-.807-.026-1.566-.248-2.228-.616v.061c0 2.385 1.693 4.374 3.946 4.827-.413.111-.849.171-1.296.171-.314 0-.615-.03-.916-.086.631 1.953 2.445 3.377 4.604 3.417-1.68 1.319-3.809 2.105-6.102 2.105-.39 0-.779-.023-1.17-.067 2.189 1.394 4.768 2.209 7.557 2.209 9.054 0 13.999-7.496 13.999-13.986 0-.209 0-.42-.015-.63.961-.689 1.8-1.56 2.46-2.548l-.047-.02z"/></svg>
      </a>
      

      
      <a class="ml-0 footer-link icon" href="https://instagram.com/adisaktijrs" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="Instagram">
        <svg class="instagram svg-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Instagram</title><path d="M12 0C8.74 0 8.333.015 7.053.072 5.775.132 4.905.333 4.14.63c-.789.306-1.459.717-2.126 1.384S.935 3.35.63 4.14C.333 4.905.131 5.775.072 7.053.012 8.333 0 8.74 0 12s.015 3.667.072 4.947c.06 1.277.261 2.148.558 2.913.306.788.717 1.459 1.384 2.126.667.666 1.336 1.079 2.126 1.384.766.296 1.636.499 2.913.558C8.333 23.988 8.74 24 12 24s3.667-.015 4.947-.072c1.277-.06 2.148-.262 2.913-.558.788-.306 1.459-.718 2.126-1.384.666-.667 1.079-1.335 1.384-2.126.296-.765.499-1.636.558-2.913.06-1.28.072-1.687.072-4.947s-.015-3.667-.072-4.947c-.06-1.277-.262-2.149-.558-2.913-.306-.789-.718-1.459-1.384-2.126C21.319 1.347 20.651.935 19.86.63c-.765-.297-1.636-.499-2.913-.558C15.667.012 15.26 0 12 0zm0 2.16c3.203 0 3.585.016 4.85.071 1.17.055 1.805.249 2.227.415.562.217.96.477 1.382.896.419.42.679.819.896 1.381.164.422.36 1.057.413 2.227.057 1.266.07 1.646.07 4.85s-.015 3.585-.074 4.85c-.061 1.17-.256 1.805-.421 2.227-.224.562-.479.96-.899 1.382-.419.419-.824.679-1.38.896-.42.164-1.065.36-2.235.413-1.274.057-1.649.07-4.859.07-3.211 0-3.586-.015-4.859-.074-1.171-.061-1.816-.256-2.236-.421-.569-.224-.96-.479-1.379-.899-.421-.419-.69-.824-.9-1.38-.165-.42-.359-1.065-.42-2.235-.045-1.26-.061-1.649-.061-4.844 0-3.196.016-3.586.061-4.861.061-1.17.255-1.814.42-2.234.21-.57.479-.96.9-1.381.419-.419.81-.689 1.379-.898.42-.166 1.051-.361 2.221-.421 1.275-.045 1.65-.06 4.859-.06l.045.03zm0 3.678c-3.405 0-6.162 2.76-6.162 6.162 0 3.405 2.76 6.162 6.162 6.162 3.405 0 6.162-2.76 6.162-6.162 0-3.405-2.76-6.162-6.162-6.162zM12 16c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4zm7.846-10.405c0 .795-.646 1.44-1.44 1.44-.795 0-1.44-.646-1.44-1.44 0-.794.646-1.439 1.44-1.439.793-.001 1.44.645 1.44 1.439z"/></svg>
      </a>
      

      
      <a class="ml-0 footer-link icon" href="https://stackoverflow.com/story/tobiasreithmeier" target="_blank" style="text-decoration: none" rel="noreferrer" aria-label="StackOverflow">
        <svg class="stackoverflow svh-hov" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Stack Overflow</title><path d="M15.725 0l-1.72 1.277 6.39 8.588 1.716-1.277L15.725 0zm-3.94 3.418l-1.369 1.644 8.225 6.85 1.369-1.644-8.225-6.85zm-3.15 4.465l-.905 1.94 9.702 4.517.904-1.94-9.701-4.517zm-1.85 4.86l-.44 2.093 10.473 2.201.44-2.092-10.473-2.203zM1.89 15.47V24h19.19v-8.53h-2.133v6.397H4.021v-6.396H1.89zm4.265 2.133v2.13h10.66v-2.13H6.154Z"/></svg>
      </a>
      

    </div>
  
</div>

        </div>
      </div>

    </div>

  </div>
  <script src="/js/nanobar.min.js"></script>
  <script>
    var options = {
      classname: 'nanobar',
      id: 'myNanobar'
    };
    var nanobar = new Nanobar(options);
    nanobar.go(30);
    nanobar.go(76);
    nanobar.go(100);
  </script>

</body>

</html>
